/**
 * Copyright (C) 2020 TU Dresden
 *
 * Micro-benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 *
 * According to the Savina paper performance can be achieved by
 * batch processing messages in the worker actors.
 * This is not possible with reactors because scheduling and
 * advancing logical time occurs after each round of
 * message delivery.
 *
 * @author Hannes Klein
 * @author Felix Wittwer
 * @author Johannes HayeÃŸ
 */


target Rust {
    build-type: Release,
    cargo-features: ["cli"],
    cargo-dependencies: {
        volatile: {
            version: "0.4",
        },
    }
};

import BenchmarkRunner from "../lib/BenchmarkRunner.lf";

reactor ThroughputReactor {
    input inMessage: unit;

    reaction(inMessage) {=
        perform_computation(37.2);
    =}

    preamble {=
        use volatile::Volatile;

        pub fn perform_computation(theta: f64) {
            let sint = theta.sin();
            let res = sint * sint;

            // defeat dead code elimination
            let v = Volatile::new(&res);
            let _ = v.read();
        }
    =}
}

reactor ThroughputProducer(total_messages:usize(10000), num_consumer:usize(60)) {
    state total_messages(total_messages);
    state num_consumer(num_consumer);

    state messages_sent:usize(0);
    state next_consumer:usize(0);
    state num_consumer_finished:usize(0);

    input inStart:unit;
    output outFinished:unit;

    output outMessage: unit;

    logical action sendNextMessage;

    reaction(inStart) -> sendNextMessage {=
        // reset local state
        self.messages_sent = 0;
        self.next_consumer = 0;
        self.num_consumer_finished = 0;

        // start execution
        ctx.schedule(sendNextMessage, Asap);
    =}

    reaction(sendNextMessage) -> outMessage, sendNextMessage, outFinished {=
        ctx.set(outMessage, ());
        self.messages_sent += 1;

        if self.messages_sent < self.total_messages {
            ctx.schedule(sendNextMessage, Asap);
        } else {
            ctx.set(outFinished, ());
        }
    =}
}

main reactor (num_iterations:usize(12), num_messages_per_reactor:usize(10000), num_workers:usize(60)) {
    state num_iterations(num_iterations);
    state num_messages_per_reactor(num_messages_per_reactor);
    state num_workers(num_workers);

    producer = new ThroughputProducer(total_messages=num_messages_per_reactor, num_consumer=num_workers);
    runner = new BenchmarkRunner(num_iterations=num_iterations);

    runner.start -> producer.inStart;
    producer.outFinished -> runner.finished;

    reaction(startup) {=
        print_benchmark_info("Throughput benchmark");
        print_args!(
            "num_iterations",
            self.num_iterations,
            "num_messages_per_reactor",
            self.num_messages_per_reactor,
            "num_workers",
            self.num_workers
        );
        print_system_info();
    =}

    worker = new[num_workers] ThroughputReactor();

    (producer.outMessage)+ -> worker.inMessage;

    preamble {=
        use crate::{print_args, reactors::benchmark_runner::{print_benchmark_info, print_system_info}};
    =}
}
